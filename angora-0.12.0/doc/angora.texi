\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename angora.info
@set UPDATED Feb 2012
@set VERSION 0.10.1 and later
@settitle Angora User's Guide
@c %**end of header

@c (IRC 02-17-2012) Rerun autoreconf after modifying this file!!

@dircategory Electromagnetic Simulation
@direntry
* Angora: (angora).           A finite-difference time-domain (FDTD) electromagnetic simulation software.
@end direntry

@copying
Copyright @copyright{} 2012 @dotaccent Ilker R. @,Capo@u glu

Portions of the @command{libconfig} manual were copied verbatim. The @command{libconfig} library is distributed under the GNU Lesser Public License, which can be found at @uref{http://www.hyperrealm.com/libconfig/libconfig_manual.html#License}.
@end copying

@titlepage
@title Angora User's Guide
@c The following two commands start the copyright page.
@subtitle A finite-difference time-domain (FDTD) electromagnetic simulation software
@subtitle for version @value{VERSION}, @value{UPDATED}
@author @dotaccent Ilker R. @,Capo@u glu
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of contents at the beginning.
@contents

@c @defindex co

@c @ifnottex @c these are not necessary if texi2html (latex2html) is used
@node Top
@top Angora: A finite-difference time-domain simulation package

This is the user's guide for Angora, a software package that computes numerical solutions to electromagnetic radiation and scattering problems. It is based on the finite-difference time-domain (FDTD) method, which one of the most popular approaches for solving Maxwell's equations of electrodynamics.
@c @end ifnottex @c these are not necessary if texi2html (latex2html) is used

@menu
* Downloading::    How to download Angora.
* Compilation and Installation::    How to compile and install Angora.
* Execution::    How to execute Angora.
* Configuration Format::    The text format for specifying simulation variables.
* Configuration Variables::    How to configure Angora for a simulation.
* References::    Bibliographic references cited in this manual.
@ifnotinfo
* List of Figures::
@end ifnotinfo
* Indices::    Concept and variable indices.
@end menu

@node Downloading
@chapter Downloading

@cindex Downloading Angora

Angora is currently only available in source-code format for the @strong{GNU/Linux operating system}. If you would like to port Angora to another operating system, please contact us at @email{capoglu@@angorafdtd.org}. Contributions are always welcome.

The latest version of Angora can be found at @uref{http://angorafdtd.org}.

@node Compilation and Installation
@chapter Compilation and Installation

@cindex Compiling Angora
@cindex Installing Angora

Angora is dependent on the following libraries: @uref{http://www.oonumerics.org/blitz/,blitz++}, @uref{http://www.hyperrealm.com/libconfig/,libconfig}, @uref{http://www.hdfgroup.org/HDF5/,hdf5}, and @uref{http://www.boost.org/,boost}. These libraries should be installed on your system before Angora can be compiled. If possible, use the package manager for your specific GNU/Linux distribution (such as Synaptic in Ubuntu) to install the libraries directly from the package repository. Most major distributions provide these libraries in their package repositories. If you do not have root access to your system, you can install these libraries in your home directory. The installation instructions for the libraries usually provide detailed information on how to do this. For local installation, the usual trick is to set the installation path by specifying the @code{prefix} variable in the @command{Makefile}s. This is done either by using the @option{--prefix=@var{local-path}} option when calling the package's @command{configure} script, or customizing @command{make} at the final stage with the @option{prefix=@var{local-path}} command option.

Once the dependency libraries are installed, the Angora package is ready for compilation. Extract the package @file{angora-@var{package-version}.tar.gz} using @command{tar}, and enter the created directory:

@example
johndoe@@mysystem:~@w{$} tar xvf angora-@var{package-version}.tar.gz
johndoe@@mysystem:~@w{$} cd angora-@var{package-version}
@end example

Run the @command{configure} script in this directory to create the @code{Makefile}s required to build the package:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} ./configure
@end example

If any of the dependency libraries was installed in a local directory, then add the option @option{--with-@var{library-name}=@var{local-path-to-library}} to the above command line. For example, if the @code{blitz++} library was installed in @file{/home/johndoe/blitz-0.9}, then the option to add is @option{--with-blitz=/home/johndoe/blitz-0.9}. Type @samp{./configure --help} in the directory @file{angora-@var{package-version}} for information on specifying the paths to the other dependency libraries.

After the @command{configure} script finishes execution, compile and install Angora using the @command{make} command:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} make
@end example

If your system has multiple cores, you can speed up the compilation by executing @command{make} in parallel. For example, you can use all 4 cores of your system by typing, instead of the above line,

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} make -j 4
@end example

This might take a couple of minutes, depending on your system. After @command{make} finishes, the executable @command{angora} will be located in the directory @file{angora-@var{package-version}}. If you wish to @emph{install} the package globally so that it can be run from anywhere, type

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} sudo make install
@end example

Obviously, this requires super-user privileges on your system. By default, the package is installed in @file{/usr/local}; so the binary will reside in @file{/usr/local/bin}. If you don't have super-user privileges, you can install Angora in a local directory @file{full-path-to-inst-dir} by typing

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} make prefix=@var{full-path-to-inst-dir} install
@end example

The location @file{full-path-to-inst-dir} should be an absolute path. After this, the binary @command{angora} will be located in the directory @file{full-path-to-inst-dir/bin/}.

@menu
* Enabling MPI Support::    Compiling Angora with MPI support.
* Building the Documentation::    Building the Angora documentation.
@end menu

@node Enabling MPI Support
@section Enabling MPI Support

@cindex MPI support, enabling
@cindex Parallelization, enabling

Parallel execution on multiple processors or cores is supported by Angora, provided that the @acronym{MPI,Message Passing Interface} libraries are installed on your system (e.g., @uref{http://www.open-mpi.org/,OpenMPI} or @uref{http://www.mcs.anl.gov/research/projects/mpich2/,MPICH2} or other). This feature has to be enabled at compile time, and is @emph{disabled} by default. You can enable MPI parallel execution in Angora by adding the option @option{--with-mpi} to the @command{configure} command line:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} ./configure --with-mpi
@end example

For more information on launching Angora simulations on multiple processors or cores using MPI, @pxref{Parallel Execution}.

@node Building the Documentation
@section Building the Documentation

@cindex Documentation, building

The GNU @code{info} documentation for Angora is automatically built and installed by @command{make}. If you have the @uref{http://www.mathematik.uni-kl.de/~obachman/Texi2html/,texi2html} and @uref{http://www.latex2html.org/,latex2html} utilities installed, you can create an HTML version of the Angora documentation by typing

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} make html
@end example

If you have the @command{texi2dvi} command available (provided as part of the @uref{http://www.gnu.org/software/texinfo/,GNU Texinfo} package), you can also build a PDF version of the Angora documentation by typing

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} make pdf
@end example

Once built, both the HTML and PDF versions of the documentation will be located in the subdirectory @file{doc/}.

@node Execution
@chapter Execution

@cindex Running Angora
@cindex Executing Angora

Angora operates by reading a text file, called the @dfn{configuration file}, that specifies the details of the simulation. Every aspect of the simulation is configured by a related @dfn{configuration variable} (or @dfn{variable} in short) in the configuration file; which comprises either a single line or a number of lines. In general, an Angora simulation is run by putting the name of the configuration file pertaining to the simulation as a command line option when calling the @command{angora} executable:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} ./angora @var{path-to-config-file}
@end example

If the Angora executable is run without any command-line options, it looks for the configuration file named @file{angora.cfg} in the same directory from which the executable is run. @xref{Configuration Variables}, for details on configuration files.

@menu
* Parallel Execution::    Parallel execution using MPI libraries.
@end menu

@node Parallel Execution
@section Parallel Execution

@cindex MPI support
@cindex Parallelization
@cindex Simulations, parallelizing

If Angora is compiled with MPI support, then the standard MPI launcher (@command{mpirun}) can be used to execute the Angora binary @command{angora} in parallel:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$}@/ mpirun -n @var{num-of-processors}@/ ./angora @var{path-to-config-file}
@end example

For example, to run the simulation configured by @file{mysimulation.cfg} using Angora version @code{0.9} on 8 processors, one should type

@example
johndoe@@mysystem:~/angora-0.9@w{$} mpirun -n 8 ./angora mysimulation.cfg
@end example

MPI support should be enabled in compile time in order to run simulations in parallel. For details, @pxref{Enabling MPI Support}.

@node Configuration Format
@chapter Configuration Format

@cindex Configuration format
@cindex libconfig

Angora uses the @uref{http://www.hyperrealm.com/libconfig/,libconfig} library to read configuration variables regarding the simulation from a text file. The text file, called the @dfn{configuration file}, has to conform to the libconfig grammar; which is explained in greater detail at @uref{http://www.hyperrealm.com/libconfig/libconfig_manual.html}. Here, we will provide the minimum information necessary to write configuration files for Angora simulations.

@menu
* Variable Assignment::    Assignment format for simulation variables.
* Variable Types::    Types of values that can be assigned to simulation variables.
@end menu

@node Variable Assignment
@section Variable Assignment

@cindex Configuration variables, assigning

A variable in a configuration file is set using the following assignment:

@example
@var{name}=@var{value};
@end example

or:

@example
@var{name}:@var{value};
@end example

The trailing semicolon is required. Whitespace is not significant. Here, @var{name} is the name of the variable, and @var{value} is its value; which may be a scalar value, an array, a group, or a list. @xref{Variable Types}, for information on these value types.

The order in which variables are specified in the configuration file is insignificant, except within the @code{SimulationSpace} variable (@pxref{Simulation Space}). The sub-variables of the @code{SimulationSpace} variable are processed in the order of appearance in the configuration file. This is necessary because the user needs to be able to control the order in which objects are placed in the grid, and predict the regions within an object that will be overwritten by another object.

@node Variable Types
@section Variable Types

@cindex Configuration variables, value types

Angora simulation variables can be assigned C++-type @dfn{scalar} values, as well as more complex values of type @dfn{group}, @dfn{array}, and @dfn{list}. The latter types are defined by the libconfig library. Some of the text in this section is copied verbatim from the @uref{http://www.hyperrealm.com/libconfig/libconfig_manual.html,libconfig manual}. The @command{libconfig} library, along with its documentation, is distributed under the @uref{http://www.hyperrealm.com/libconfig/libconfig_manual.html#License,GNU Lesser Public License}.

@menu
* Integer Values::
* Floating-Point Values::
* Boolean Values::
* String Values::
* Groups::
* Arrays::
* Lists::
* Comments::
* Include Directives::
@end menu

@node Integer Values
@subsection Integer Values

@cindex Integer values

Integers can be represented in one of two ways: as a series of one or
more decimal digits (@samp{0} - @samp{9}), with an optional leading
sign character (@samp{+} or @samp{-}); or as a hexadecimal value
consisting of the characters @samp{0x} followed by a series of one or
more hexadecimal digits (@samp{0} - @samp{9}, @samp{A} - @samp{F},
@samp{a} - @samp{f}).

Examples:

@example
n_sx = 3;
offset = -4;
address = 0xFFFF;
@end example

@node Floating-Point Values
@subsection Floating-Point Values

@cindex Floating-point values

Floating point values consist of a series of one or more digits, one
decimal point, an optional leading sign character (@samp{+} or
@samp{-}), and an optional exponent. An exponent consists of the
letter @samp{E} or @samp{e}, an optional sign character, and a series
of one or more digits.

Except in special circumstances, floating-point values in Angora are read and processed in @samp{double} precision, which corresponds to roughly 15 decimal digits.

Examples:

@example
f = 1.0;
origin = -3e-6;
prefactor = 5E10;
@end example

@node Boolean Values
@subsection Boolean Values

@cindex Boolean values

Boolean values may have one of the following values: @samp{true},
@samp{false}, or any mixed-case variation thereof.

Examples:

@example
include_first_value = true;
include_last_value = FaLsE;
@end example

@node String Values
@subsection String Values

@cindex String values

String values consist of arbitrary text delimited by double
quotes. Literal double quotes can be escaped by preceding them with a
backslash: @samp{\"}. The escape sequences @samp{\\}, @samp{\f},
@samp{\n}, @samp{\r}, and @samp{\t} are also recognized, and have the
usual meaning.

In addition, the @samp{\x} escape sequence is supported; this sequence
must be followed by @i{exactly two} hexadecimal digits, which represent an
8-bit ASCII value. For example, @samp{\xFF} represents the character
with ASCII code 0xFF.

No other escape sequences are currently supported.

Adjacent strings are automatically concatenated, as in C/C++ source
code. This is useful for formatting very long strings as sequences of
shorter strings. For example, the following constructs are equivalent:

@itemize @bullet
@item
@code{"The quick brown fox jumped over the lazy dog."}

@item
@code{"The quick brown fox"} @*
@code{" jumped over the lazy dog."}

@item
@code{"The quick" /* comment */ " brown fox " // another comment} @*
@code{"jumped over the lazy dog."}

@end itemize

@node Groups
@subsection Groups

@cindex Groups

A group has the form:

@example
@{
   @var{name}=@var{value};
   @var{other_name}=@var{other_value};
   @dots{}
@}
@end example

Notice the curly brackets @samp{@{@}} around the variable assignments. Groups can contain any number of variable assignments (see @ref{Variable Assignment}), but each variable must have a unique name within the group.

Example:

@example
SphereProperties:
@{
    position_x = 0;
    position_y = 0;
    position_z = 0;
    visible = true;
@};
@end example

@node Arrays
@subsection Arrays

@cindex Arrays

An array has the form:

@example
[ @var{value}, @var{value}, @dots{} ]
@end example

Notice the square brackets @samp{[]} delimiting the comma-separated values. An array may have zero or more elements, but the elements must all be @strong{scalar} values of the @strong{same type}.

Examples:

@example
disabled_runs = [0,1,3];
output_variables = ["Ex","Ey"];
@end example

@node Lists
@subsection Lists

@cindex Lists

A list has the form:

@example
( @var{value}, @var{value}, @dots{} )
@end example

Notice the parantheses @samp{()} delimiting the comma-separated values. A list may have zero or more elements, each of which can be a scalar value, an array, a group, or another list. The values in a list can be of @emph{different types}; however, in Angora, the list type is exclusively used to contain a collection of @emph{group} values. In Angora, the list type  semantically represents a collection of objects, each with a collection of properties set within their respective group value. Here is an example:

@example
Materials:
(
    @{
        material_tag = "mat1";
        rel_permittivity = 2.0;
    @},
    @{
        material_tag = "mat2";
        rel_permittivity = 2.5;
    @}
);
@end example

Here, the list structure named @code{Materials} contains two groups (each delimited by curly brackets @samp{@{@}}) separated by a comma. This defines two materials with different sets of properties.
@c This is currently the only use of the list structure in Angora.

@node Comments
@subsection Comments

@cindex Comments, inserting

Three types of comments are allowed within a configuration:

@itemize @bullet

@item Script-style comments. All text beginning with a @samp{#} character
to the end of the line is ignored.

@item C-style comments. All text, including line breaks, between a starting
@samp{/*} sequence and an ending @samp{*/} sequence is ignored.

@item C++-style comments. All text beginning with a @samp{//} sequence to the
end of the line is ignored.

@end itemize

As expected, comment delimiters appearing within quoted strings are
treated as literal text.

@example
# Here's a comment
MyGroup:
(/* This is
    also a comment */
    @{
        this_property = "myvalue";
        // Another comment
    @}
);
@end example

@node Include Directives
@subsection Include Directives

@cindex Including other configuration files

A configuration file may ``include'' the contents of another file
using an @i{include directive}. This directive has the effect of
inlining the contents of the named file at the point of inclusion.

An include directive must appear on its own line in the input. It has
the form:

@example
@@include "@var{filename}"
@end example

Any backslashes or double quotes in the file name must be escaped as
@samp{\\} and @samp{\"}, respectively.

For example, consider the following two configuration files:

@cartouche
@smallexample
# file: limits.cfg
back_x = -5e-6;
front_x = 6e-6;
left_y = -5e-6;
right_y = 6e-6;
lower_z = -3e-6;
upper_z = 4e-6;
@end smallexample
@end cartouche

@cartouche
@smallexample
# file: mysim.cfg
RectangularBoxes:
(
    @{
        shape_tag = "mybox";
        @@include "limits.cfg"
    @}
);
@end smallexample
@end cartouche

Include files may be nested to a maximum of 10 levels; exceeding this
limit results in a runtime error.

@node Configuration Variables
@chapter Configuration Variables

@cindex Configuring Angora simulations
@cindex Configuration variables
@cindex Simulations, configuring

The variable assignments (or @dfn{settings} in libconfig terminology) in a configuration file reside either at the uppermost level (called the @dfn{Global} level) or within a group structure (@pxref{Groups}). In the following, configuration variables will be characterized as either being a @dfn{Global variable}, or a @dfn{Sub-variable of @var{ParentVariable}}; where @var{ParentVariable} is the next parent variable upward in the hierarchy that has a name. The variable @var{ParentVariable} can either be a @emph{group} or a @emph{list} (see @ref{Groups} and @ref{Lists}). Quite often, the immediate parent of a variable assignment is an unnamed group; therefore the @var{ParentVariable} of that assignment is the list that contains this unnamed group. For example, the @var{ParentVariable} of the variable @code{material_tag} in the example in @ref{Lists} is @code{Materials}, since its immediate parent is an unnamed group, but the list structure containing the unnamed group has a name (which is @code{Materials}). On the other hand, the variable @code{Materials} is a @dfn{Global variable}; since it is assigned at the uppermost level in a configuration file, outside any enclosing structure.

The configuration variable names are case sensitive; meaning that @code{Materials} and @code{materials} are not the same.

@menu
* Grid Properties::    Basic properties of the FDTD grid.
* Shapes::    Defining abstract geometrical shapes.
* Materials::    Defining material types.
* Simulation Space::    Specifying the material composition of the simulation space.
* Waveforms::    Defining time waveforms.
* Point Sources::    Defining point (Hertzian) sources.
* Near-Field-to-Far-Field Transform::    Calculation of the radiated (far-zone) field.
* Optical Imaging::    Calculation of optical images.
* Incident Wave Conditions::    Injection of incident beams into the grid.
* Recording::    Movie/line/field-value recording.
* Paths::    Specifying the input and output directories.
* Logging::    Enabling and configuring log output.
* Multiple Simulation Runs::    Configuring the number of consecutive simulations.
* Miscellaneous::    Miscellaneous features.
@end menu

@node Grid Properties
@section Grid Properties

Angora currently only supports a rectangular, Cartesian FDTD grid with equal grid spacing in the x, y, and z directions. Mesh refinement is not yet supported; therefore the grid spacing is uniform across the grid.

@menu
* Courant Factor::    The ratio between the temporal and spatial step sizes.
* Spatial Step Size::    The spatial step size in the FDTD grid.
* Grid Dimensions::    The number of FDTD cells in the x, y, and z directions.
* Perfectly-Matched Layer (PML)::    Absorbing layers for grid termination.
* Number of Time Steps::    Number of time steps in the simulation.
* Coordinate Origin::    Origin of the coordinate system.
* Dynamic Range::    The maximum field value and the useful dB dynamic range in the simulation.
@end menu

@node Courant Factor
@subsection Courant Factor

@deftypevr {Global variable} floating-point courant
Angora adopts a slightly modified form for the Courant factor, defined as
@tex
$$
{1 \over \sqrt{3}} {c\Delta t \over \Delta x}
$$
@end tex

@ifnottex
c*D_t/(sqrt(3)*D_x)
@end ifnottex
 
where c=299792458 m/s is the speed of light in vacuum, and
@tex 
$\Delta t $
@end tex
@ifnottex 
D_t
@end ifnottex 
and
@tex 
$\Delta x $
@end tex
@ifnottex 
D_x
@end ifnottex 
are the @emph{temporal} and @emph{spatial} step sizes (see @ref{Spatial Step Size}). The Courant factor should be less than @code{1.0} for stability. A common value for @code{courant} is @code{0.98}.
@c The Courant factor is commonly defined without the 
@c @tex 
@c $1/\sqrt{3} $
@c @end tex
@c @ifnottex 
@c 1/sqrt(3)
@c @end ifnottex 
@c factor.
@end deftypevr

@node Spatial Step Size
@subsection Spatial Step Size

@deftypevr {Global variable} floating-point dx (units: m)
The spatial step size in the FDTD grid is specified by the @code{dx} variable. Currently only cubic FDTD cells are supported; therefore the spatial step sizes in the x, y, and z direction are all determined by @code{dx}.
@end deftypevr

@node Grid Dimensions
@subsection Grid Dimensions

@deftypevr {Global variable} integer NCELLS_X
@end deftypevr

@deftypevr {Global variable} integer NCELLS_Y
@end deftypevr

@deftypevr {Global variable} integer NCELLS_Z
These variables determine the number of FDTD cells (or voxels) in the Cartesian FDTD grid in the x, y, and z directions. If no perfectly-matched layers are specified (see @ref{Perfectly-Matched Layer (PML)}), the total number of FDTD cells in the three-dimensional FDTD grid is equal to (NCELLS_X) x (NCELLS_Y) x (NCELLS_Z).
@end deftypevr

@node Perfectly-Matched Layer (PML)
@subsection Perfectly-Matched Layer (PML)

@deftypevr {Global variable} integer NPML
This variable sets the thickness (in grid cells) of the perfectly-matched layers (PMLs) around the grid. This sets the thickness of the PML in  in all directions. Further customization of the PML thickness is not yet supported.

Typical PML thicknesses are @code{5} to @code{10}. If you do not want to place a PML layer around the grid, just assign @code{NPML=0}. Without a PML layer, the boundary of the FDTD grid acts as a perfect electric conductor (PEC). Other boundary conditions (perfect magnetic conductor, periodic, etc.) will also be supported in the future.

With a PML definition, the total number of FDTD cells in the three-dimensional FDTD grid becomes (NCELLS_X+2*NPML) x (NCELLS_Y+2*NPML) x (NCELLS_Z+2*NPML). The computational burden per FDTD cell associated with the PML layer is roughly twice that of the main grid.

Angora implements the convolution PML (CPML) formulation of the complex-frequency shifted (CFS) PML (see @ref{Roden00}; @ref{Kuzuoglu96}.) 
@end deftypevr

@deftypevr {Global variable} integer CPML_feature_size (default: @code{max(NCELLS_X,NCELLS_Y,NCELLS_Z)})
This variable specifies the maximum size (in grid cells) of the scattering or radiating structure in the FDTD grid. This information is used to determine the frequency-shifting parameter 
@tex
$\alpha$
@end tex
@ifnottex
@emph{alpha} 
@end ifnottex
in the CFS-PML formulation. Following Berenger's derivation (see @ref{Berenger02}), this parameter is defined as
@tex
$$
\alpha = c\epsilon/w
$$
@end tex

@ifnottex
alpha = c*eps/w
@end ifnottex 

where c is the velocity of propagation in the medium,
@tex
$\epsilon$
@end tex
@ifnottex
@emph{eps} 
@end ifnottex
is the absolute permittivity (in F/m) in the medium, and
@tex
$w$
@end tex
@ifnottex
@emph{w}
@end ifnottex
is the maximum size of the structure.

The above relationship follows essentially from the low-frequency behavior of the CFS-PML. At low frequencies where the evanescent field around the structure dominates, the CFS-PML reduces to a real stretch of coordinates without any absorption. This helps the termination of evanescent fields, which are poorly handled by ordinary PMLs.
@end deftypevr

@node Number of Time Steps
@subsection Number of Time Steps

@deftypevr {Global variable} integer NSTEPS
This variable determines the number of time steps in the FDTD simulation.
@end deftypevr

@node Coordinate Origin
@subsection Coordinate Origin

@deftypevr {Global variable} integer OriginX (default: (NCELLS_X+2*NPML)/2+1)
@end deftypevr

@deftypevr {Global variable} integer OriginY (default: (NCELLS_X+2*NPML)/2+1)
@end deftypevr

@deftypevr {Global variable} integer OriginZ (default: (NCELLS_X+2*NPML)/2+1)
These variables set the origin of the coordinate system in the simulation. All other coordinates in a configuration file are taken as relative to this origin. The integer values correspond to Cartesian coordinates of the origin (in grid cells) from the back-left-lower corner of the grid. 
@ifinfo
See printed manual for a graphical illustration.
@end ifinfo
@ifnotinfo
In @ref{fig:grid_origin,this figure}, the location of the coordinate origin in the FDTD grid is shown for (@code{OriginX},@code{OriginY},@code{OriginZ})=(2,3,1). The FDTD grid is composed of (3x5x3) grids, and only the back (y=z=0), left (x=z=0), and lower (x=y=0) surfaces are shown in the figure.

@float Figure,fig:grid_origin
@center @image{grid_origin,4in}
@caption{The location of the coordinate origin in the FDTD grid for (@code{OriginX},@code{OriginY},@code{OriginZ})=(2,3,1).}
@end float
@end ifnotinfo
@end deftypevr

@node Dynamic Range
@subsection Dynamic Range

The following two variables are only relevant in movie recording (see @ref{Movie Recording}), wherein the floating-point field values on the movie frames are sometimes discretized to fit into 1 byte.
@deftypevr {Global variable} floating-point max_field_value (default: @code{1.0})
This value specifies the maximum field value used in the discretization for 1-byte movie recording (@pxref{Movie Recording}).
@end deftypevr

@deftypevr {Global variable} floating-point dB_accuracy (default: automatic)
This value specifies the dynamic range (in dB) to be used in the discretization for 1-byte movie recording (@pxref{Movie Recording}). For example,

@example
dB_accuracy = -60;
@end example

tells Angora to discretize the field values in a dynamic range between the maximum field value (specified by @code{max_field_value} above) and 60dB below that value. If @code{dB_accuracy} is not specified, Angora tries to set this value automatically, based on its best guess on the useful accuracy range in the simulation. This value can also be read from the output of the movie recorder (@pxref{Movie Recording}).
@end deftypevr

@node Shapes
@section Shapes

@deftypevr {Global variable} group Shapes
In Angora, a geometrical shape and the material filling that shape are two distinct and independent elements of the definition of an object. The first of these elements is defined in the @code{Shapes} variable, which is a group (@pxref{Groups}).

@example
Shapes:
@{
    RectangularBoxes:
    (
            @dots{}
            @dots{}
    );
    Spheres:
    (
            @dots{}
            @dots{}
    );
@};
@end example

In this example, two sub-variables @code{RectangularBoxes} and @code{Spheres} of the @code{Shapes} group are shown. These are both list variables (@pxref{Lists}).
@end deftypevr

Currently, rectangular boxes and spheres are the only basic shape classes defined in Angora. Unions, intersections, and geometrical transformations of shapes, as well as more basic shape classes will be added to Angora in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

@menu
* Rectangular Boxes::
* Spheres::
@end menu

@node Rectangular Boxes
@subsection Rectangular Boxes

@deftypevr {Sub-variable of Shapes} group RectangularBoxes

Rectangular boxes are defined using the @code{RectangularBoxes} variable, which is a list structure under the @code{Shapes} group.

@example
Shapes:
@{
    RectangularBoxes:
    (
        @{
            shape_tag = "mybox";
            back_x = -5e-6;
            front_x = 6e-6;
            left_y = -5e-6;
            right_y = 6e-6;
            lower_z = -3e-6;
            upper_z = 4e-6;
        @},
        @{
            shape_tag = "another_box";
            @dots{}
            @dots{}
        @}
    );
@};
@end example

In this example, two rectangular box shapes are defined in two respective unnamed groups; only the first being shown in complete detail.

@deftypevr {Sub-variable of RectangularBoxes} string shape_tag
This string variable assigns a @emph{name} to the particular shape, so it can be referred to later in the configuration file.
@end deftypevr

@deftypevr {Sub-variable of RectangularBoxes} floating-point back_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point front_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point left_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point right_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point lower_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point upper_z (units: m)
These variables determine the minimum and maximum Cartesian coordinates of the box in the x, y, and z directions relative to the grid origin (@pxref{Coordinate Origin}).
@end deftypevr

@end deftypevr

@node Spheres
@subsection Spheres

@deftypevr {Sub-variable of Shapes} group Spheres

Spheres are defined using the @code{Spheres} variable, which is a list structure under the @code{Shapes} group.

@example
Shapes:
@{
    Spheres:
    (
        @{
            shape_tag = "mysphere";
            center_x = 5e-6;
            center_y = 5e-6;
            center_z = 5e-6;
            radius = 4e-6;
        @},
        @{
            shape_tag = "another_sphere";
            @dots{}
            @dots{}
        @}
    );
@};
@end example

In this example, two spherical shapes are defined in two respective unnamed groups; only the first being shown in complete detail.

@deftypevr {Sub-variable of Spheres} string shape_tag
This string variable assigns a @emph{name} to the particular shape, so it can be referred to later in the configuration file.
@end deftypevr

@deftypevr {Sub-variable of Spheres} floating-point center_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of Spheres} floating-point center_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of Spheres} floating-point center_z (units: m)
These variables determine the Cartesian coordinate of the center of the sphere relative to the grid origin (@pxref{Coordinate Origin}).
@end deftypevr
@deftypevr {Sub-variable of Spheres} floating-point radius (units: m)
This variable determines the radius of the sphere.
@end deftypevr

@end deftypevr

@node Materials
@section Materials

Currently, Angora only supports isotropic, non-dispersive materials. Anisotropic and dispersive materials will also be supported in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

@deftypevr {Global variable} list Materials
The properties of a certain material type are specified in the @code{Materials} list (@pxref{Lists}).
@example
Materials:
(
    @{
        material_tag = "this_material";
        rel_permittivity = 2.0;
        rel_permeability = 1.0;
        electric_conductivity = 0.0;
        magnetic_conductivity = 0.0;
    @},
    @{
        material_tag = "another_material";
        @dots{}
        @dots{}
    @}
);
@end example

In this example, two materials are defined in two respective unnamed groups; only the first being shown in complete detail.

@deftypevr {Sub-variable of Materials} string material_tag
This string variable assigns a @emph{name} to the particular material, so it can be referred to later in the configuration file.
@end deftypevr
@deftypevr {Sub-variable of Materials} floating-point rel_permittivity
This (mandatory) variable specifies the relative permittivity (or the dielectric constant) of the material. In SI units, the absolute permittivity of the material is this variable multiplied by the permittivity of free space (8.85418782E-12 F/m).
@end deftypevr
@deftypevr {Sub-variable of Materials} floating-point rel_permeability (default: @code{1.0})
This variable specifies the relative permeability (or the magnetic constant) of the material. In SI units, the absolute permeability of the material is this variable multiplied by the permeability of free space (4piE-7).
@end deftypevr
@deftypevr {Sub-variable of Materials} floating-point electric_conductivity (units: S/m) (default: @code{0})
This variable specifies the electric conductivity (in Siemens/m or Mho/m) of the material.
@end deftypevr
@deftypevr {Sub-variable of Materials} floating-point magnetic_conductivity (units: Ohm/m) (default: @code{0})
This variable specifies the magnetic conductivity (in Ohm/m) of the material.
@end deftypevr

@end deftypevr

@node Simulation Space
@section Simulation Space

@deftypevr {Global variable} group SimulationSpace
The @code{SimulationSpace} group is where all the objects inside the simulation space are defined.
@example
SimulationSpace:
@{
    Objects:
    (
            @dots{}
            @dots{}
    );
    RandomMaterials:
    @{
            @dots{}
            @dots{}
    @};

    @dots{}
    @dots{}

@};
@end example

In the above example, only two of the sub-variables of the @code{SimulationSpace} group, @code{Objects} and @code{RandomMaterials}, are shown. The sub-variable @code{Objects} is a list (see @ref{Lists}), whereas @code{RandomMaterials} is a group (see @ref{Groups}).

The definitions in the @code{SimulationSpace} group are processed @strong{in the order of placement}. Thus, the user has complete control over which object is placed in the simulation space first. As a consequence of this first-come-first-serve policy, objects can overwrite regions of the simulation space occupied by other objects.
@end deftypevr

@menu
* Objects::    Material objects defined as a combination of a @code{Shapes} object and a @code{Materials} object.
* Planar Layers::    Planar material layers.
* Random Materials::    Material blocks having random material properties with a specified spatial correlation function.
* File Input::    Reading a region of the simulation grid from a file.
* Ground Planes::    Perfectly-conducting planar sheets.
@end menu

@node Objects
@subsection Objects

@deftypevr {Sub-variable of SimulationSpace} list Objects
The @code{Objects} list defines material objects to be placed in the simulation grid. An @emph{object} in this context is defined as a combination of two abstract ingredients: A previously-defined shape (see @ref{Shapes}), and a previously-defined material to fill that shape (see @ref{Materials}). The shape and material are referred to using their shape and material tags, which are string variables assigned to them in their definitions.

Here is an example:

@example
SimulationSpace:
@{
    Objects:
    (
        @{
            material_tag = "this_material";
            shape_tag = "mysphere";
        @},
        @{
            material_tag = "another_material";
            shape_tag = "mybox";
        @}
    );
@};
@end example

@deftypevr {Sub-variable of Objects} string material_tag
This string variable specifies the material that makes up the object. It should match a previously-defined tag in a @code{Materials} definition (@pxref{Materials}).
@end deftypevr

@deftypevr {Sub-variable of Objects} string shape_tag
This string variable specifies the geometrical shape of the object. It should match a previously-defined tag in a @code{Shapes} definition (@pxref{Shapes}).
@end deftypevr

@end deftypevr

@node Planar Layers
@subsection Planar Layers

@deftypevr {Sub-variable of SimulationSpace} list MaterialSlabs

The purpose of the @code{MaterialSlab} list is to introduce @strong{planar stratification} into the simulation grid. Currently, Angora only supports planar stratification along the z direction. The handling of planar layers will be further improved in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

Here is an example:

@example
SimulationSpace:
@{
    MaterialSlabs:
    (
        @{
            tag = "material1";
            min_coord = 400.46;
            max_coord = 500.0;
        @},
        @{
            tag = "material2";
            min_coord = "min";
            max_coord = 300.0;
        @}
    );
@};
@end example

In the above example, two material slabs are placed in the grid. They are composed of @code{material1} and @code{material2}, respectively.

@deftypevr {Sub-variable of MaterialSlabs} string tag
This variable specifies the material that makes up the slab. It should match a previously-defined tag in a @code{Materials} definition (@pxref{Materials}).
@end deftypevr
@deftypevr {Sub-variable of MaterialSlabs} floating-point/string min_coord
@end deftypevr
@deftypevr {Sub-variable of MaterialSlabs} floating-point/string max_coord
These two floating-point variables specify the lower and upper coordinates (in grid cells) of the material slab with respect to the grid origin (@pxref{Coordinate Origin}). These can be non-integer; in which case the layer boundaries are suitably interpolated. These variables can also be assigned the string values @code{"min"} or @code{"max"}; which correspond to the lower and upper boundaries of the simulation grid, respectively.
@end deftypevr

If the FDTD grid is terminated by absorbing PML boundaries (see @ref{Perfectly-Matched Layer (PML)}), then the @code{MaterialSlab} definitions effectively create @emph{infinite planar layers} that extend horizontally toward infinity. When the @code{"min"} or @code{"max"} strings are assigned as lower or upper coordinates of the slab, the @code{MaterialSlab} definition amounts to placing a @emph{half space}. When the @code{MaterialSlab} variable is used, the incident beams (see @ref{Incident Wave Conditions}) and the scattered far field (see @ref{Near-Field-to-Far-Field Transform}) are both calculated as if the material slab horizontally extends toward infinity.
@end deftypevr

@node Random Materials
@subsection Random Materials

@deftypevr {Sub-variable of SimulationSpace} group RandomMaterials
Independent samples from a random distribution of material properties with a specified correlation function can be generated and placed into the simulation grid using the @code{RandomMaterials} group. It contains sub-variables in the form of lists (see @ref{Lists}) that correspond to specific correlation functions. Currently, only the @emph{Whittle-Matern} family of correlation functions is supported. More correlation functions can be added in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

Although the spatial correlation of the generated random material blocks can vary, the joint probability density function of the material block is always a @emph{multivariate normal (Gaussian) function}.

@deftypevr {Sub-variable of RandomMaterials} list WhittleMaternCorrelated

The Whittle-Matern family of correlations (see @ref{Rogers09}) is a three-parameter isotropic stochastic model that can represent a wide range of spatial correlations. The Whittle-Matern correlation function 
@tex
$B(r)$
@end tex
@ifnottex
B(r)
@end ifnottex 
for two points separated in space by a distance of
@tex
$r$
@end tex
@ifnottex
r
@end ifnottex 
is given by the formula
@tex
$$
B(r) = \sigma^{2}
	{{2^{5/2-m}(r/l_c)^{m-3/2}}\over{\Gamma(m-3/2)}}
	K_{m-3/2}(r/l_c)\ 
$$
@end tex

@ifnottex
B(r)=2^(5/2-m)(sigma^2)*(r/lc)^(m-3/2)*BesselK(m-3/2,r/lc)/Gamma(m-3/2)
@end ifnottex 

where
@tex
$K_{m-3/2}(\cdot)$
@end tex
@ifnottex
BesselK(m-3/2,r/lc)
@end ifnottex 
is the modified Bessel function of the second kind and order (m-3/2). 
@itemize
@item
@tex
$m$:
@end tex
@ifnottex
m:
@end ifnottex 
The shape parameter that determines the overall behavior of the correlation function. As m->infinity, the function approaches a Gaussian distribution. If m=2, the function reduces to a decaying exponential. For m<3/2, the distribution acquires an inverse power law dependence near the origin; approximating a fractal distribution. For more details, see @ref{Rogers09}.

@item
@tex
$l_c$:
@end tex
@ifnottex
lc:
@end ifnottex 
(For m>3/2:) The correlation length. (For m<=3/2:) Loosely, the outer length scale where the fractal approximation no longer holds.

@item
@tex
$\sigma$:
@end tex
@ifnottex
sigma:
@end ifnottex 
(For m>3/2:) The standard deviation of the distribution at a given point (r=0). (For m<=3/2:) In this range, the correlation function enters the fractal regime with an inverse-power-law dependence at the origin (see @ref{Rogers09}). The meaning of 
@tex
$\sigma$
@end tex
@ifnottex
sigma
@end ifnottex 
becomes more subtle in this regime. It can loosely be associated with the amplitude of the correlation between two points separated by 
@tex
$l_c$.
@end tex
@ifnottex
lc.
@end ifnottex 
@end itemize

The @code{WhittleMaternCorrelated} list creates blocks with random material properties described by the Whittle-Matern correlation function above. Here is an example of its usage:

@example
SimulationSpace:
@{
    RandomMaterials:
    @{
        WhittleMaternCorrelated:
        (
            @{
                constitutive_param_type = "rel_permittivity";
                mean = 1.33;
                std_dev = 0.05;
                corr_len = 100e-9;
                m = 2.0;
                back_coord = -10.0;
                front_coord = 10.0;
                left_coord = -10.0;
                right_coord = 10.0;
                lower_coord = -10.0;
                upper_coord = 10.0;
                random_seed = 0;
            @}
        );
    @};

@};
@end example

@deftypevr {Sub-variable of WhittleMaternCorrelated} string constitutive_param_type
The Whittle-Matern correlation function can describe the relative permittivity, relative permeability, or electric conductivity (in Siemens/m) of the material block. This is specified by assigning @code{"rel_permittivity"}, @code{"rel_permeability"}, or @code{"electric_conductivity"} to the @code{constitutive_param_type} string variable.
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point mean (units: none or S/m)
A baseline constant value equal to @code{mean} is added to the constitutive parameter described by the Whittle-Matern correlation function. If @code{mean=0}, then the generated random distribution will have zero mean. However, this will not necessarily be reflected to the actual constitutive parameter values in the grid; since Angora will automatically clip the constitutive parameters (permittivity, permeability, conductivity, etc.) from below to either unity or zero to avoid instabilities. For this reason, @code{mean} should be high enough to avoid this clipping as much as possible. As a rule of thumb, @code{mean} should be 5 to 6 times the standard deviation (@code{std_dev}) above unity or zero.
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point std_dev (units: none or S/m)
This variable specifies the 
@tex
$\sigma$
@end tex
@ifnottex
sigma
@end ifnottex 
parameter in the definition of the Whittle-Matern correlation function.
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point corr_len (units: m)
This variable specifies the 
@tex
$l_c$
@end tex
@ifnottex
lc
@end ifnottex 
parameter in the definition of the Whittle-Matern correlation function.
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point m
This variable specifies the 
@tex
$m$
@end tex
@ifnottex
m
@end ifnottex 
parameter in the definition of the Whittle-Matern correlation function.
@end deftypevr

@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point back_coord
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point front_coord
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point left_coord
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point right_coord
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point lower_coord
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point upper_coord
These variables determine the bounding coordinates (in grid cells) of the rectangular prism containing the random material. The coordinates are with respect to the grid origin (@pxref{Coordinate Origin}).
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} integer/string random_seed (default: determined by system time)
If you would like to create @emph{exactly the same random distribution} each time the simulation is run, you can assign an integer value to the @code{random_seed} variable. Otherwise, you @strong{should not} define this variable. This value is used to initialize the random-number generator in Angora. If the same seed is used to initialize the random-number generator, the same sequence of random numbers will be generated each time, resulting in the same random distribution.

If multiple simulation runs are present (see @ref{Multiple Simulation Runs}), you can create different random samples for each simulation run by assigning the string value @code{"run_index"} to @code{random_seed}. This will initialize the intenal random-number generator with the run index (ranging from @code{0} to @code{number_of_runs-1}) of each run. This way, a different random distribution will be obtained in each simulation run; but a distribution for a given simulation run will be @emph{fixed} in subsequent executions of Angora.
@end deftypevr
@ifinfo
See printed manual for an example of a random distribution.
@end ifinfo

@ifnotinfo
In @ref{fig:random_sample,this figure}, a 2D slice of an example zero-mean sample distribution generated by @code{WhittleMaternCorrelated} is depicted in grayscale.

@float Figure,fig:random_sample
@center @image{random_sample,4in}
@caption{A 2D slice of an example zero-mean sample distribution. This distribution can be assigned to different constitutive parameters of a material.}
@end float
@end ifnotinfo

@end deftypevr
@end deftypevr

@node File Input
@subsection File Input

@deftypevr {Sub-variable of SimulationSpace} list MaterialsFromFiles
Material information within rectangular regions of the FDTD simulation grid can be read from files using a @code{MaterialsFromFiles} list. Currently, only a single constitutive parameter can be read from a file; and dispersive or anisotropic materials are not supported. These issues will be handled more comprehensively in a future version. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

The material file should be in a simple custom binary format that Angora can recognize. The order and type of each variable in the file is explained below:
@itemize
@item
@samp{x-extent}: The extent of the array in the x direction in grid cells (integer, 4 bytes)
@item
@samp{y-extent}: The extent of the array in the y direction in grid cells (integer, 4 bytes)
@item
@samp{z-extent}: The extent of the array in the z direction in grid cells (integer, 4 bytes)
@item
A floating-point array of length (@code{x-extent}) x (@code{y-extent}) x (@code{z-extent}). Each value in this array is either of type @code{double} (8 bytes) or @code{float} (4 bytes), depending on the @code{datatype} variable (see @ref{datatype,@code{datatype}}). The floating-point array should be laid out in the file in @emph{column-major} order, meaning that the x dimension is looped over first, then the y dimension, and finally the z dimension. 
@ifinfo
See printed manual for a graphical illustration of the column-major order.
@end ifinfo
@ifnotinfo
This ordering is depicted in @ref{fig:column_major,the following figure}. The elements of the 2x2x2 array are numbered from 0 to 7. These elements should be laid out in the binary file in the same order:

@cartouche
@example
@dots{}@dots{} 0  1  2  3  4  5  6  7  @dots{}@dots{}
@end example
@end cartouche

@float Figure,fig:column_major
@center @image{column_major,4in}
@caption{The illustration of the column-major ordering of a three-dimensional array. The values indicated by numbers should be laid out in the file in the same order.}
@end float
@end ifnotinfo

@end itemize

Here is an example usage of @code{MaterialsFromFiles}:

@example
SimulationSpace:
@{
    MaterialsFromFiles:
    (
        @{
            file_name = "path_to_file/materialfile";
            append_run_index_to_name = true;
            file_extension = "mat";
            constitutive_param_type = "rel_permittivity";
            anchor = "center";
            position_x = 131;
            position_y = 131;
            position_z = 131;
            datatype = "double";
            max_new_materials = 1000;
        @}
    );
@};
@end example
@deftypevr {Sub-variable of MaterialsFromFiles} string file_name
This string specifies the name of the binary file from which the material information will be read. Path information can be prepended to the file name, as shown in the example above. This path is interpreted as being relative to @code{input_dir} (see @ref{Paths}), unless it is preceded by a slash @samp{/}.
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} string file_extension (default: "")
This is the extension of the material file to be read. In the above example, the file to be read is @file{path_to_file/materialfile.mat}.
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} boolean append_run_index_to_name
This boolean flag becomes useful if there are multiple simulation runs (see @ref{Multiple Simulation Runs}), and a different file needs to be read in each run. This can be accomplished by appending the run index (which ranges from @code{0} to @code{number_of_runs-1}) to the file name specified by @code{file_name}. For example, if there are 3 simulation runs (@code{number_of_runs} is 3) the above assignment will tell Angora to read the file @file{path_to_file/materialfile0.mat} in the first run, @file{path_to_file/materialfile1.mat} in the second, and @file{path_to_file/materialfile2.mat} in the third.

This variable is required for all simulations (hence no default value) to help the user prevent easy mistakes such as reading the same file for all simulation runs unintentionally, reading @file{path_to_file/materialfile0.mat} instead of @file{path_to_file/materialfile.mat}, etc.
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} string constitutive_param_type
The values read from the input file can be assigned to one of the following constitutive parameters: relative permittivity, relative permeability, or electric conductivity. This is determined by assigning @code{"rel_permittivity"}, @code{"rel_permeability"}, or @code{"electric_conductivity"} to the @code{constitutive_param_type} string variable. Electric conductivity is assumed to be in Siemens/m.
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} string anchor (default: @code{"center"})
This string defines an anchor point inside the rectangular-box-shaped region that is to be read from this file. This anchor is then assigned a coordinate in the FDTD grid, thereby determining the position of the rectangular box in the grid. Valid values for @code{anchor} are:
@itemize
@item 
@code{"center"}: center of the box
@item 
@code{"BLL"}: back-left-lower corner of the box
@item 
@code{"BLU"}: back-left-upper corner of the box
@item 
@code{"BRL"}: back-right-lower corner of the box
@item 
@code{"BRU"}: back-right-upper corner of the box
@item 
@code{"FLL"}: front-left-lower corner of the box
@item 
@code{"FLU"}: front-left-upper corner of the box
@item 
@code{"FRL"}: front-right-lower corner of the box
@item 
@code{"FRU"}: front-right-upper corner of the box
@end itemize
Here, as usual, "back"/"front" refers to the x coordinate, "left"/"right" refers to the y coordinate, and "lower"/"upper" refers to the z coordinate.
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} integer position_x
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} integer position_y
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} integer position_z
These integer values determine the Cartesian x,y, and z coordinates of the anchor point (see above) assigned to the rectangular region to be read from the file. The coordinates are measured in grid cells from the grid origin (@pxref{Coordinate Origin}).
@end deftypevr
@anchor{datatype}@deftypevr {Sub-variable of MaterialsFromFiles} string datatype
The datatype for the values read from the file is determined by this variable. It should be either @code{"double"} (8 bytes) or @code{"float"} (4 bytes).
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} integer max_new_materials (default: @code{1000})
Internally, Angora uses @emph{material indexing} to reduce memory use for material arrays. Each material with a distinct set of constitutive parameters is assigned an index value of type @code{unsigned short} (2 bytes) that can range from @code{0} to @code{65,535}. Instead of storing a floating-point value (which is usually 4 or 8 bytes) for a permittivity value at a point, Angora stores an @emph{index} that represents the material present at that point.

Each time a material region is read into the FDTD grid using @code{MaterialsFromFiles}, a fixed number of new materials are added to the material list. These materials cover a discrete range of constitutive parameters between the minimum and maximum values found in the file. Because of this discretization, some loss of information is inevitable. The number of new materials is determined by the variable @code{max_new_materials}; which is by equal to 1000 default. With the default value, the upper limit for the number of materials will be reached after about 65 material regions are inserted into the grid. If you wish to insert more material regions, and the dynamic ranges of constitutive parameters in your material files are not large, you can decrease @code{max_new_materials}.
@end deftypevr
@end deftypevr

@node Ground Planes
@subsection Ground Planes

@deftypevr {Sub-variable of SimulationSpace} list GroundPlanes
Infinitely thin perfect-electric-conductor (PEC) sheets can be placed in the grid using a @code{GroundPlanes} list. Currently, only z-oriented (parallel to the xy plane) sheets at integer (full-cell) positions are supported.

@example
SimulationSpace:
@{
    GroundPlanes:
    (
        @{
            coord = 0.0;
        @}
    );
@};
@end example

@deftypevr {Sub-variable of GroundPlanes} integer coord
This integer variable specifies the z-coordinate (in grid cells) of the ground plane with respect to the grid origin (@pxref{Coordinate Origin}).
@end deftypevr

The @code{GroundPlanes} variable also updates the layering (stratification) information in the grid, much like @code{MaterialSlabs} (@pxref{Planar Layers}).

@end deftypevr


@node Waveforms
@section Waveforms

@deftypevr {Global variable} group Waveforms
In Angora, a @emph{time waveform} is defined as a self-contained structure that can be used by other structures; such as a Hertzian dipole source or a plane-wave injector. The library of available time waveforms will be expanded in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

An example usage of @code{Waveforms}:
@example
Waveforms:
@{
    GaussianWaveforms:
    (
        @{
            @dots{}
        @}
    );

    DifferentiatedGaussianWaveforms:
    (
        @{
            @dots{}
        @}
    );
    @dots{}
    @dots{}
@};
@end example
@end deftypevr

@menu
* Gaussian Waveforms::
* Differentiated-Gaussian Waveforms::
* Modulated-Gaussian Waveforms::
@end menu

@node Gaussian Waveforms
@subsection Gaussian Waveforms
@deftypevr {Sub-variable of Waveforms} list GaussianWaveforms
This variable is used to define Gaussian time waveforms given by the formula
@anchor{eq:gaussian}
@tex
$$
f(t)=A\ \exp\left({{-(t-n_{\tau}\tau)^{2}}\over{2\tau^{2}}}\right)
$$
@end tex

@ifnottex
f(t)=A*exp(-(t-n_tau*tau)^2/2tau^2)
@end ifnottex

Gaussian waveforms are defined as follows:

@example
Waveforms:
@{
    GaussianWaveforms:
    (
        @{
            tag = "my_waveform";
            amplitude = 1.0;
            tau = 2.1291e-15;
            delay = 3;
        @}
    );
@};
@end example

@deftypevr {Sub-variable of GaussianWaveforms} string tag
This is the string tag by which the waveform will later be referred to by another structure that requires a time waveform in its definition.
@end deftypevr
@deftypevr {Sub-variable of GaussianWaveforms} floating-point amplitude (default: @code{1.0})
This specifies the variable
@tex
$A$
@end tex
@ifnottex
A
@end ifnottex
in @ref{eq:gaussian,the above equation} defining the Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of GaussianWaveforms} floating-point tau (units: sec)
This specifies the variable
@tex
$\tau$
@end tex
@ifnottex
tau
@end ifnottex
in @ref{eq:gaussian,the above equation} defining the Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of GaussianWaveforms} floating-point delay (default: @code{0.0})
This specifies the variable
@tex
$n_{\tau}$
@end tex
@ifnottex
n_tau
@end ifnottex
in @ref{eq:gaussian,the above equation} defining the Gaussian waveform.
@end deftypevr
@end deftypevr

@node Differentiated-Gaussian Waveforms
@subsection Differentiated-Gaussian Waveforms

@deftypevr {Sub-variable of Waveforms} list DifferentiatedGaussianWaveforms
This variable is used to define differentiated Gaussian time waveforms, given by the formula
@anchor{eq:diffgaussian}
@tex
$$
f(t)=A\ {{d^n}\over {dt^n}}\left[\exp\left({{-(t-n_{\tau}\tau)^{2}}\over{2\tau^{2}}}\right)\right]
=A\ ({{-1}\over{\tau\,\sqrt{2}}})^{n}H_{n}\left({{t-n_{\tau}\tau}\over{\tau\,\sqrt{2}}}\right)\exp\left({{-(t-n_{\tau}\tau)^{2}}\over{2\tau^{2}}}\right)
$$
@end tex

@ifnottex
f(t)=A*(D^n/Dt^n][exp(-(t-n_tau*tau)^2/2tau^2)]
@end ifnottex

@ifnotinfo
where @math{H_n(x)} are the (physicists') @uref{http://en.wikipedia.org/wiki/Hermite_polynomial#Definition,Hermite polynomials}.
@end ifnotinfo

Differentiated Gaussian waveforms are defined as follows:

@example
Waveforms:
@{
    DifferentiatedGaussianWaveforms:
    (
        @{
            tag = "my_waveform";
            amplitude = 1.0;
            tau = 2.1291e-15;
            delay = 3;
            n = 3;
        @}
    );
@};
@end example

@deftypevr {Sub-variable of DifferentiatedGaussianWaveforms} string tag
This is the string tag by which the waveform will later be referred to by another structure that requires a time waveform in its definition.
@end deftypevr
@deftypevr {Sub-variable of DifferentiatedGaussianWaveforms} floating-point amplitude (default: @code{1.0})
This specifies the variable
@tex
$A$
@end tex
@ifnottex
A
@end ifnottex
in @ref{eq:diffgaussian,the above equation} defining the differentiated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of DifferentiatedGaussianWaveforms} floating-point tau (units: sec)
This specifies the variable
@tex
$\tau$
@end tex
@ifnottex
tau
@end ifnottex
in @ref{eq:diffgaussian,the above equation} defining the differentiated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of DifferentiatedGaussianWaveforms} floating-point delay (default: @code{0.0})
This specifies the variable
@tex
$n_{\tau}$
@end tex
@ifnottex
n_tau
@end ifnottex
in @ref{eq:diffgaussian,the above equation} defining the differentiated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of DifferentiatedGaussianWaveforms} integer n
This specifies the order of differentiation
@tex
$n$
@end tex
@ifnottex
n
@end ifnottex
in @ref{eq:diffgaussian,the above equation} defining the differentiated Gaussian waveform.
@end deftypevr
@end deftypevr

@node Modulated-Gaussian Waveforms
@subsection Modulated-Gaussian Waveforms

@deftypevr {Sub-variable of Waveforms} list ModulatedGaussianWaveforms
This variable is used to define sinusoidally-modulated Gaussian time waveforms, given by the formula
@anchor{eq:modgaussian}
@tex
$$
f(t)=A\ g\big(2\pi f_0 (t-n_{\tau}\tau)+\phi\big)\exp\left({{-(t-n_{\tau}\tau)^{2}}\over{2\tau^{2}}}\right)
$$
@end tex

@ifnottex
f(t)=A*g(2*pi*f_0(t-n_tau\tau)+extra_phase)exp(-(t-n_tau*tau)^2/2tau^2)
@end ifnottex

where the function
@tex
$g(t)$
@end tex
@ifnottex
g(t)
@end ifnottex
is a sinusoidal function, being either
@tex
$\sin(t)$
@end tex
@ifnottex
sin(t)
@end ifnottex
or
@tex
$\cos(t)$
@end tex
@ifnottex
cos(t)
@end ifnottex
.

Modulated Gaussian waveforms are defined as follows:

@example
Waveforms:
@{
    ModulatedGaussianWaveforms:
    (
        @{
            tag = "my_waveform";
            modulation_type = "sine";
            amplitude = 1.0;
            tau = 2.1291e-15;
            f_0 = 5.8929e14;
            delay = 3;
            phase = 90;
            differentiated = false;
        @}
    );
@};
@end example

@deftypevr {Sub-variable of ModulatedGaussianWaveforms} string tag
This is the string tag by which the waveform will later be referred to by another structure that requires a time waveform in its definition.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} string modulation_type
If assigned @code{"sine"}, the modulation function 
@tex
$g(t)$
@end tex
@ifnottex
g(t)
@end ifnottex
in @ref{eq:modgaussian,the above equation} becomes a sine. If assigned @code{"cosine"}, it becomes a cosine.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} floating-point amplitude (default: @code{1.0})
This specifies the variable
@tex
$A$
@end tex
@ifnottex
A
@end ifnottex
in @ref{eq:modgaussian,the above equation} defining the modulated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} floating-point tau (units: sec)
This specifies the variable
@tex
$\tau$
@end tex
@ifnottex
tau
@end ifnottex
in @ref{eq:modgaussian,the above equation} defining the modulated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} floating-point f_0 (units: Hz)
This specifies the modulation frequency
@tex
$f_0$
@end tex
@ifnottex
f_0
@end ifnottex
in @ref{eq:modgaussian,the above equation} defining the modulated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} floating-point delay (default: @code{0.0})
This specifies the variable
@tex
$n_{\tau}$
@end tex
@ifnottex
n_tau
@end ifnottex
in @ref{eq:modgaussian,the above equation} defining the modulated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} floating-point phase (units: degrees, default: @code{0.0})
This specifies the extra phase
@tex
$\phi$
@end tex
@ifnottex
extra_delay
@end ifnottex
in @ref{eq:modgaussian,the above equation} defining the modulated Gaussian waveform. This phase should be specified in @emph{degrees}, which is then converted internally to radians, which are the actual units of 
@tex
$\phi$
@end tex
@ifnottex
extra_delay
@end ifnottex
.
@end deftypevr
@end deftypevr

@node Point Sources
@section Point Sources

@deftypevr {Global variable} list PointSources
"Infinitesimal" electric dipole sources (also called @emph{Hertzian} dipoles) can be simulated in Angora using the @code{PointSources} list.

A Hertzian dipole at position
@tex
$(x_0,y_0,z_0)$
@end tex
@ifnottex
(x0,y0,z0)
@end ifnottex
is characterized by the following current distribution in space:

@tex
$$
J(x,y,z;t)={\bf a}\,j_0(t)\,\delta(x-x_0)\delta(y-y_0)\delta(z-z_0)
$$
@end tex
@ifnottex
J(x,y,z;t)=^a*j0(t)*delta(x-x0)delta(y-y0)delta(z-z0)
@end ifnottex

where
@tex
$\delta(x)$
@end tex
@ifnottex
delta(x)
@end ifnottex
is the Dirac delta function. The vector
@tex
{\bf a}
@end tex
@ifnottex
^a
@end ifnottex
determines the orientation of the dipole, which can be along the x, y, or z directions.
The prefactor
@tex
$j_0(t)$
@end tex
@ifnottex
j0(t)
@end ifnottex
is called the @emph{current moment} of the dipole, with the units (Ampere*m).

Here is an example usage of @code{PointSources}:

@example
PointSources:
(
    @{
        position_x = 0;
        position_y = 0;
        position_z = 0;
        source_orientation = "y_directed";
        waveform_tag = "moment_waveform";
        j0 = 1.0;
    @}
);
@end example

@deftypevr {Sub-variable of PointSources} integer position_x
@end deftypevr
@deftypevr {Sub-variable of PointSources} integer position_y
@end deftypevr
@deftypevr {Sub-variable of PointSources} integer position_z
These integer variables specify (in grid cells) the Cartesian x, y, and z coordinates of the Hertzian dipole with respect to the grid origin (@pxref{Coordinate Origin}).
@end deftypevr
@deftypevr {Sub-variable of PointSources} string source_orientation
This string specifies the spatial orientation of the Hertzian dipole. It should be @code{"x_directed"}, @code{"y_directed"}, or @code{"z_directed"}.
@end deftypevr

@deftypevr {Sub-variable of PointSources} string waveform_tag
This string variable specifies the waveform of the current moment
@tex
$j_0(t)$
@end tex
@ifnottex
j0(t)
@end ifnottex
. The waveform is interpreted in (Ampere*m) units. This should match a previously-defined tag in a @code{Waveforms} definition (@pxref{Waveforms}).
@end deftypevr
@deftypevr {Sub-variable of PointSources} floating-point j0 (units: Ampere/m, default: @code{1.0})
This is an extra prefactor applied to the current moment waveform 
@tex
$j_0(t)$
@end tex
@ifnottex
j0(t)
@end ifnottex
.
@end deftypevr

@end deftypevr

@node Near-Field-to-Far-Field Transform
@section Near-Field-to-Far-Field Transform

Blah.

@node Optical Imaging
@section Optical Imaging

Blah.

@node Incident Wave Conditions
@section Incident Wave Conditions

Blah.

@node Recording
@section Recording

Angora can record field values computed during a simulation into a file in a variety of ways. Field values can be recorded on a cross-section of the grid, along a line through the grid, or at a given point in the grid. Currently, Angora only supports the recording of the electric field. Recording of the magnetic field, as well as the energy, Poynting's vector, etc. will be implemented in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

@anchor{recorder_output_dir}@deftypevr {Global variable} string recorder_output_dir (default: @code{"recorder"})
This determines the subdirectory in which all the recording-related stuff will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{output_dir} (@pxref{Paths}).

@example
recorder_output_dir = "recorder";
Recorder:
@{
        @dots{}
        @dots{}
@};
@end example
@end deftypevr

@deftypevr {Global variable} group Recorder
The @code{Recorder} group contains the sub-variables related to different types of field recording. These are explained in the following subsections.

@example
Recorder:
@{
    MovieRecorders:
    (
        @{
            @dots{}
            @dots{}
        @}
    );
    LineRecorders:
    (
        @{
            @dots{}
            @dots{}
        @}
    );
    FieldValueRecorders:
    (
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example
@end deftypevr

@menu
* Movie Recording::
* Line Recording::
* Field-Value Recording::
@end menu

@node Movie Recording
@subsection Movie Recording

Angora can record field components on a two-dimensional cross section of the grid into a custom movie file. The binary format used for movie recording is described in more detail in @ref{Movie File Format}.

@anchor{movie_recorder_output_dir}@deftypevr {Sub-variable of Recorder} string movie_recorder_output_dir (default: @code{""})
This determines the subdirectory in which all the recorded movie files will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{recorder_output_dir} (see @ref{recorder_output_dir,@code{recorder_output_dir}}).

@example
Recorder:
@{
    movie_recorder_output_dir = "movies";
    MovieRecorders:
    (
        @dots{}
        @dots{}
    );
@};
@end example
@end deftypevr

@deftypevr {Sub-variable of Recorder} list MovieRecorders

Field values on a two-dimensional cross section of the FDTD grid can be recorded using the @code{MovieRecorders} list.

@example
Recorder:
@{
    MovieRecorders:
    (
        @{
            recorded_section = "xz";
            recorded_position = 0;
            recorded_component = "Ex";
            recording_scale = "dB";
            recording_type = "uchar1";
            movie_dir = "this_movie_dir";
            movie_file_name = "MovieFile"
            movie_file_extension = "amv";
            only_records_material_info = false;
        @}
    );
@};
@end example

@deftypevr {Sub-variable of MovieRecorders} string recorded_section
This determines the cross section of the grid over which the field is recorded. Currently, only xz, yz, and xy cross sections are supported. These are represented by the string values @code{"xz"}, @code{"yz"}, and @code{"xy"}, respectively.
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} integer recorded_position
This integer value specifies (in grid cells) the coordinate of the recorded cross section along the perpendicular direction (e.g., the z direction if @code{recorded_section} is @code{"xy"}). The coordinate is relative to the grid origin (@pxref{Coordinate Origin}).
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} string recorded_component
An individual movie recorder (in a group delineated by the curly brackets @samp{@{@}}) only records a single scalar value extracted from the vector-valued electric field. This could be one of the Cartesian components of the electric field, or its absolute value. These are represented by the string values @code{"Ex"}, @code{"Ey"}, @code{"Ez"}, and @code{"E"}, respectively. If you would like to record multiple Cartesian components of the electric field, simply add other movie recorders (i.e., other groups, see @ref{Groups}) to the @code{MovieRecorders} list with the desired @code{recorded_component} values.
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} string recording_scale
If @code{"linear"}, the raw values are recorded. If @code{"absolute"}, the absolute value is taken before recording. If @code{"dB"}, the decibel value
@tex
$(20\log_{10}(|\cdot|))$
@end tex
@ifnottex
(20*log10(|x|))
@end ifnottex
is recorded.
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} string recording_type
Movies can either be recorded either in raw floating-point format, or in a single-byte compressed format. This is specified by assigning the string values @code{"dbl8"} or @code{"uchar1"} to the @code{recording_type} variable, respectively. Using the single-byte format reduces the file size considerably, but results in some data loss.

If @code{recording_type} is @code{"dbl8"}, then the field values are recorded in 8-byte @code{double} datatype, after processed in accordance with the @code{recording_scale} specification above. This provides practically lossless recording, albeit with increased computational burden and file size.

With the @code{"uchar1"} option, the field values are reduced to 256 discrete bins within a fixed @emph{dynamic range}. This requires only a single byte per field value; reducing the storage requirement by a factor of 8.
@itemize
@item
If @code{recording_type} is @code{"dB"}, the maximum and minimum values in this dynamic range are determined by the global variables @code{max_field_value} and @code{dB_accuracy} (see @ref{Dynamic Range}):
@tex
$${\bf max:\ }20\log_{10}(|{\rm max\_field\_value}|)
\quad {\bf min:\ } 20\log_{10}(|{\rm max\_field\_value}|)+({\rm dB\_accuracy})$$
@end tex

@ifnottex
max:  20*log10(|max_field_value|)

min:  20*log10(|max_field_value|)+(dB_accuracy)
@end ifnottex

The @code{dB_accuracy} variable should always be negative; therefore the minimum value in the dynamic range is lower than the maximum.

@item
If @code{recording_type} is @code{"linear"} or@code{"absolute"}, the maximum and minimum values are determined only by the global variable @code{max_field_value} (see @ref{Dynamic Range}):
@tex
$${\bf max:\ }{\rm max\_field\_value}
\qquad {\bf min:\ } ({\rm -max\_field\_value})\ \  {\rm or }\ \  0$$
@end tex

@ifnottex
max:  max_field_value

min:  (-max_field_value) or 0
@end ifnottex
@end itemize
@end deftypevr

@deftypevr {Sub-variable of MovieRecorders} string movie_dir (default: @code{""})
This determines the subdirectory in which this individual movie file will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{movie_recorder_output_dir} (see @ref{movie_recorder_output_dir,@code{movie_recorder_output_dir}}). By default, no subdirectory is created inside @code{movie_recorder_output_dir}.
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} string movie_file_name (default: @code{"MovieFile"})
This determines the base string in the full name of the movie file. Other information is appended to the name of the file to differentiate individual movie files (see the example below).
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} string movie_file_extension (default: @code{"amv"})
This is the extension of the movie file name. If assigned the value @code{""}, no extension is added to the file.
@end deftypevr
@anchor{movie_filename_example} Here is an example movie file name:
@example
MovieFile_Ex_0_1.amv
@end example
The base string in the name of the file (@code{"MovieFile"}) is specified by the @code{movie_file_name} variable. The second part of the file name, @code{"Ex"}, is determined by the recorded field component. The two integers that follow are the run index (see @ref{Multiple Simulation Runs}) and the index of the movie inside the @code{MovieRecorders} list. For example, if there are two groups (two movies) in the @code{MovieRecorders} list, the first one will write into
@example
MovieFile_Ex_0_0.amv
@end example
while the second will write into
@example
MovieFile_Ex_0_1.amv
@end example
If there are two simulation runs (i.e., @code{number_of_runs} is equal to 2 -- see @ref{Multiple Simulation Runs}), then the files created in the second run will have @code{1} instead of @code{0} as the first integer in the above file names. Finally, the extension (@code{"amv"}) of the movie files is determined by the variable @code{movie_file_extension}.

@deftypevr {Sub-variable of MovieRecorders} boolean only_records_material_info (default: @code{false})
If set to @code{true}, only the material information is recorded into the file, and no field recording is performed during the simulation.
@end deftypevr

@end deftypevr

@menu
* Movie File Format::    Custom binary format for the movie output.
@end menu

@node Movie File Format
@subsubsection Movie File Format

Angora records movies in a custom binary format for better speed and performance. Please be aware that this format is subject to modification. The changes in the format will be documented in this manual as necessary. You may refer to the @file{ChangeLog} file in the Angora distribution for recent changes in the movie recording format.

The MATLAB script @file{angora_movie.m}, distributed as part of the Angora package, reads an Angora movie file and displays it as a MATLAB movie. It can also save the movie in AVI format. This script is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}.

The movie file is composed of chunks of data, ordered as follows. For each chunk, a short explanation (and maybe an alias) is given, followed by a description of the datatype in parantheses.

@itemize
@item
major package version (integer, 4 bytes)
@item
minor package version (integer, 4 bytes)
@item
package revision number (integer, 4 bytes)
@item
number of bytes used to record each field component (integer, 4 bytes):  This is either equal to @code{1} or @code{8}, depending on the @code{recording_type} variable.
@item
spatial step size (double, 8 bytes)
@item
temporal step size (double, 8 bytes)
@item
time value that corresponds to the beginning of the simulation (double, 8 bytes):  This is usually a negative value, since time waveforms frequently begin before t=0.
@item
maximum value in the field discretization range (double, 8 bytes):  This is the maximum value in the discretization dynamic range for single-byte recording (i.e., @code{recording_type} is @code{"uchar1"}). If @code{recording_type} is @code{"dbl8"}, this value is irrelevant. Same applies to the next value in the file.
@item
minimum value in the field discretization range (double, 8 bytes)
@item
@samp{length_1}: length along the first dimension of the recorded array (integer, 4 bytes):  If the xy section were recorded, this would be the length of the array in the x dimension. This includes the thickness of the PML sections in both directions.
@item
@samp{length_2}: length along the second dimension of the recorded array (integer, 4 bytes):  If the xy section were recorded, this would be the length of the array in the y dimension. This includes the thickness of the PML sections in both directions.
@item
@samp{length_time}: number of time steps in the simulation (integer, 4 bytes)
@item
thickness of the PML region, in grid cells (integer, 4 bytes):  See @ref{Perfectly-Matched Layer (PML)} for more information on the PML. The PML sections are included in the recorded cross sectional area. They can easily be removed in post-processing. 
@item
an array of length @code{length_1} with the actual physical coordinates (in m) along the first dimension of the recorded cross section (double, 8 bytes)
@item
an array of length @code{length_2} with the actual physical coordinates (in m) along the second dimension of the recorded cross section (double, 8 bytes)
@item
an array of length (@code{length_2} x @code{length_1}) holding the relative-permittivity values on the recorded cross section (double, 8 bytes):  
@ifinfo
See printed manual for a graphical illustration of the 2D data layout in the movie-file .
@end ifinfo
@ifnotinfo
In @ref{fig:movie_file_layout,this figure}, it is assumed that the xy section is recorded, and the field positions are numbered from 0 to 11. It is seen that the @strong{second dimension} (here, the y-dimension) is looped through first. These positions are laid out in the movie file in the same order:

@cartouche
@example
0  1  2  3  4  5  6  7  8  9  10  11
@end example
@end cartouche

@float Figure,fig:movie_file_layout
@center @image{movie_file_layout,3in}
@caption{The layout of the field positions on the recorded cross section in the movie file.}
@end float
@end ifnotinfo

@item
an array of length (@code{length_2} x @code{length_1}) holding the electric conductivity values (in Siemens/m) on the recorded cross section (double, 8 bytes):  The 2D cross section is laid out in the movie file in the same way as the previous array.

@item
arrays (movie frames) of length (@code{length_2} x @code{length_1}) holding the field values on the recorded cross section (double, 8 bytes OR unsigned char, 1 byte -- depending on @code{recording_type}):  The total number of these movie frames is equal to @code{length_time}, read earlier from the binary file. Each of these frames is laid out in the movie file in the same way as the previous arrays.
@end itemize



@node Line Recording
@subsection Line Recording

Angora can record field components along a line into a file. The binary format used for line recording is described in more detail in @ref{Line File Format}.

@anchor{line_recorder_output_dir}@deftypevr {Sub-variable of Recorder} string line_recorder_output_dir (default: @code{""})
This determines the subdirectory in which all the recorded line files will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{recorder_output_dir} (see @ref{recorder_output_dir,@code{recorder_output_dir}}).

@example
Recorder:
@{
    line_recorder_output_dir = "lines";
    LineRecorders:
    (
        @dots{}
        @dots{}
    );
@};
@end example
@end deftypevr

@deftypevr {Sub-variable of Recorder} list LineRecorders

@example
Recorder:
@{
    LineRecorders:
    (
        @{
            line_orientation = "y_directed";
            line_position_x1 = 0;
            line_position_x2 = 0;
            recorded_component = "Ex";
            recording_scale = "linear";
            line_dir = "this_line_dir";
            line_file_name = "LineFile";
            line_file_extension = "aln";
        @}
    );
@};
@end example

@deftypevr {Sub-variable of LineRecorders} string line_orientation
There are three possible orientations for the line over which the field values are recorded .These orientations are along the three principal axes of the grid; namely, the x,y, and z directions. These are specified by the strings @code{"x_directed"}, @code{"y_directed"}, and @code{"z_directed"}, respectively.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} integer line_position_x1
This is the first of the remaining two coordinates that specify the position of the recorded line (in grid cells). The coordinate is relative to the grid origin (@pxref{Coordinate Origin}). For example, if the line is oriented in the y direction (@code{line_orientation} is @code{"y_directed"}), then @code{line_position_x1} specifies the x coordinate of the line.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} integer line_position_x2
This is the second of the remaining two coordinates that specify the position of the recorded line (in grid cells). The coordinate is relative to the grid origin (@pxref{Coordinate Origin}). For example, if the line is oriented in the y direction (@code{line_orientation} is @code{"y_directed"}), then @code{line_position_x2} specifies the z coordinate of the line.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} string recorded_component
An individual line recorder (in a group delineated by the curly brackets @samp{@{@}}) only records a single scalar value extracted from the vector-valued electric field. This could be one of the Cartesian components of the electric field, or its absolute value. These are represented by the string values @code{"Ex"}, @code{"Ey"}, @code{"Ez"}, and @code{"E"}, respectively. If you would like to record multiple Cartesian components of the electric field, simply add other line recorders (i.e., other groups, see @ref{Groups}) to the @code{LineRecorders} list with the desired @code{recorded_component} values.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} string recording_scale
If @code{"linear"}, the raw values are recorded. If @code{"absolute"}, the absolute value is taken before recording. If @code{"dB"}, the decibel value
@tex
$(20\log_{10}(|\cdot|))$
@end tex
@ifnottex
(20*log10(|x|))
@end ifnottex
is recorded.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} string line_dir (default: @code{""})
This determines the subdirectory in which this individual line file will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{line_recorder_output_dir} (see @ref{line_recorder_output_dir,@code{line_recorder_output_dir}}). By default, no subdirectory is created inside @code{line_recorder_output_dir}.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} string line_file_name (default: @code{"LineFile"})
This determines the base string in the full name of the line file. Other information is appended to the name of the file to differentiate individual line files (see the example below).
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} string line_file_extension (default: @code{"aln"})
This is the extension of the line file name. If assigned the value @code{""}, no extension is added to the file.
@end deftypevr
@anchor{line_filename_example} Here is an example line file name:
@example
LineFile_Ey_Y_0_1.aln
@end example
The base string in the name of the file (@code{"LineFile"}) is specified by the @code{line_file_name} variable. The second part of the file name, @code{"Ey"}, is determined by the recorded field component. The following string @code{"Y"} indicates the orientation of the line, which is y-directed for this example. The two integers that follow are the run index (see @ref{Multiple Simulation Runs}) and the index of the line recorder inside the @code{LineRecorders} list. For example, if there are two groups (two line recorders) in the @code{LineRecorders} list, the first one will write into
@example
LineFile_Ey_Y_0_0.aln
@end example
while the second will write into
@example
LineFile_Ey_Y_0_1.aln
@end example
If there are two simulation runs (i.e., @code{number_of_runs} is equal to 2 -- see @ref{Multiple Simulation Runs}), then the files created in the second run will have @code{1} instead of @code{0} as the first integer in the above file names. Finally, the extension (@code{"aln"}) of the line files is determined by the variable @code{line_file_extension}.

@end deftypevr

@menu
* Line File Format::    Custom binary format for the line-recorder output.
@end menu

@node Line File Format
@subsubsection Line File Format

As with movies, Angora records the line files in a custom binary format for better speed and performance. Please be aware that this format is subject to modification. The changes in the format will be documented in this manual as necessary. You may refer to the @file{ChangeLog} file in the Angora distribution for recent changes in the line recording format.

The MATLAB script @file{angora_line.m}, distributed as part of the Angora package, reads an Angora line file and displays it as a MATLAB movie. This script is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}.

The line file is composed of chunks of data, ordered as follows. For each chunk, a short explanation (and maybe an alias) is given, followed by a description of the datatype in parantheses.

@itemize
@item
major package version (integer, 4 bytes)
@item
minor package version (integer, 4 bytes)
@item
package revision number (integer, 4 bytes)
@item
temporal step size (double, 8 bytes)
@item
time value that corresponds to the beginning of the simulation (double, 8 bytes):  This is usually a negative value, since time waveforms frequently begin before t=0.
@item
@samp{total_length}: the number of recorded elements on each line snapshot (integer, 4 bytes)
@item
@samp{length_time}: number of time steps in the simulation (integer, 4 bytes)
@item
thickness of the PML region, in grid cells (integer, 4 bytes):  See @ref{Perfectly-Matched Layer (PML)} for more information on the PML. The recorded line includes two PML sections on opposite ends, each with this length. These sections can easily be removed in post-processing. 
@item
arrays (line snapshots) of length @code{total_length} holding the field values on the recorded line (double, 8 bytes):  The total number of these line snapshots is equal to @code{length_time}, read earlier from the binary file.
@end itemize


@node Field-Value Recording
@subsection Field-Value Recording

Angora can record the time history of the field at a given position in the simulation grid. The format used for this sort of recording is @strong{HDF5} (Hierarchical Data Format) (@uref{http://www.hdfgroup.org/HDF5/}). The HDF5 format was chosen for its standard interface, and the availability of free software tools for inspecting and modifying HDF5 output. The HDF5 output created by the field-value recorder is explained in more detail in @ref{Field-Value File HDF5 Content}.

@anchor{field_value_recorder_output_dir}@deftypevr {Sub-variable of Recorder} string field_value_recorder_output_dir (default: @code{""})
This determines the subdirectory in which all the recorded field-value files will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{recorder_output_dir} (see @ref{recorder_output_dir,@code{recorder_output_dir}}).

@example
Recorder:
@{
    field_value_recorder_output_dir = "fieldvalues";
    FieldValueRecorders:
    (
        @dots{}
        @dots{}
    );
@};
@end example	
@end deftypevr

@deftypevr {Sub-variable of Recorder} list FieldValueRecorders

@example
Recorder:
@{
    FieldValueRecorders:
    (
        @{
            position_x = 0;
            position_y = 0;
            position_z = 0;
            recorded_component = "Ex";
            recording_scale = "linear";
            field_value_dir = "this_field_value_dir";
            field_value_file_name = "FieldValueFile";
            field_value_file_extension = "hd5";
        @}
    );
@};
@end example

@deftypevr {Sub-variable of FieldValueRecorders} integer position_x
This is the x coordinate (in grid cells) of the recorded position in the simulation grid. It is relative to the grid origin (@pxref{Coordinate Origin}).
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} integer position_y
This is the y coordinate (in grid cells) of the recorded position in the simulation grid. It is relative to the grid origin (@pxref{Coordinate Origin}).
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} integer position_z
This is the z coordinate (in grid cells) of the recorded position in the simulation grid. It is relative to the grid origin (@pxref{Coordinate Origin}).
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} string recorded_component
An individual field-value recorder (in a group delineated by the curly brackets @samp{@{@}}) only records a single scalar value extracted from the vector-valued electric field. This could be one of the Cartesian components of the electric field, or its absolute value. These are represented by the string values @code{"Ex"}, @code{"Ey"}, @code{"Ez"}, and @code{"E"}, respectively. If you would like to record multiple Cartesian components of the electric field, simply add other field-value recorders (i.e., other groups, see @ref{Groups}) to the @code{FieldValueRecorders} list with the desired @code{recorded_component} values.
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} string recording_scale
If @code{"linear"}, the raw values are recorded. If @code{"absolute"}, the absolute value is taken before recording. If @code{"dB"}, the decibel value
@tex
$(20\log_{10}(|\cdot|))$
@end tex
@ifnottex
(20*log10(|x|))
@end ifnottex
is recorded.
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} string field_value_dir (default: @code{""})
This determines the subdirectory in which this individual field-value file will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{field_value_recorder_output_dir} (see @ref{field_value_recorder_output_dir,@code{field_value_recorder_output_dir}}). By default, no subdirectory is created inside @code{field_value_recorder_output_dir}.
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} string field_value_file_name (default: @code{"FieldValueFile"})
This determines the base string in the full name of the field-value file. Other information is appended to the name of the file to differentiate individual field-value files (see the example below).
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} string field_value_file_extension (default: @code{"hd5"})
This is the extension of the field-value file name. If assigned the value @code{""}, no extension is added to the file. The HDF5 extension @code{"hd5"} is applied by default.
@end deftypevr
@anchor{field_value_filename_example} Here is an example field-value file name:
@example
FieldValueFile_Ex_0_1.hd5
@end example
The base string in the name of the file (@code{"FieldValueFile"}) is specified by the @code{field_value_file_name} variable. The second part of the file name, @code{"Ex"}, is determined by the recorded field component. The two integers that follow are the run index (see @ref{Multiple Simulation Runs}) and the index of the field-value recorder inside the @code{FieldValueRecorders} list. For example, if there are two groups (two field-value recorders) in the @code{FieldValueRecorders} list, the first one will write into
@example
FieldValueFile_Ex_0_0.hd5
@end example
while the second will write into
@example
FieldValueFile_Ex_0_1.hd5
@end example
If there are two simulation runs (i.e., @code{number_of_runs} is equal to 2 -- see @ref{Multiple Simulation Runs}), then the files created in the second run will have @code{1} instead of @code{0} as the first integer in the above file names. Finally, the extension (@code{"hd5"}) of the line files is determined by the variable @code{field_value_file_extension}.

@end deftypevr

@menu
* Field-Value File HDF5 Content::    Explanation of the HDF5 content in the field-value-recorder output file.
@end menu

@node Field-Value File HDF5 Content
@subsubsection Field-Value File HDF5 Content

The HDF5 file created as the output of the field-value recorder can be viewed and modified using freely-available tools. One of these tools is @uref{http://www.hdfgroup.org/hdf-java-html/hdfview/,HDFView}, provided by the HDF Group. MATLAB also has built-in functions and tools that handle HDF5 files. For reference, a MATLAB script named @file{angora_fieldvalue.m} is distributed as part of the Angora package, which reads an Angora field-value file and plots the recorded waveform. This script is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}.

@c The script @file{angora_fieldvalue.m} makes use of another MATLAB script installed in the same directory, @file{hdf5_read.m}, that reads a dataset from an HDF5 file into a MATLAB array. 

The HDF5 datasets in the field-value file are the following:

@itemize
@item
@samp{angora_version}:  An integer array of length 3 with the major version, minor version, and revision numbers of the Angora package used to create the file.
@item
@samp{num_time_steps}:  An integer value specifying the number of time steps in the simulation.
@item
@samp{time_step}:  A floating-point value specifying the temporal step in the simulation.
@item
@samp{initial_time_value}:  A floating-point value specifying the time value corresponding to the beginning of the simulation. This is usually a negative value, since time waveforms frequently begin before t=0.
@item
@samp{field_values}:  A floating-point array of length @code{num_time_steps} with the recorded field values.
@end itemize


@node Paths
@section Paths

@cindex Paths, specifying
@cindex Paths, output
@cindex Paths, input

@deftypevr {Global variable} string angora_basepath  (default: @code{"."})
This variable specifies the base directory for all the input-output operations in Angora. If there is no slash @samp{/} in front of the path, it is interpreted as a relative path starting from the working directory (i.e, the one from which Angora is launched.)

Any other input or output directory will be assumed @emph{relative} to @code{angora_basepath}. An overarching exception is when a directory is specified with a slash @samp{/} up front; in which case that directory will be taken as an @emph{absolute path}, and not relative to @code{angora_basepath}.

@end deftypevr
@deftypevr {Global variable} string output_dir  (default: @code{"output"})
This is the base directory for all the output that will result from Angora. It is interpreted as being relative to @code{angora_basepath}, unless it is preceded by a slash @samp{/}. All other output directories are created as subdirectories of this directory.

Example:

@example
angora_basepath = "angora_stuff";
output_dir = "data";
@end example

With these variable assignments, all the output will be written into subdirectories within @file{./angora_stuff/data/}.
@end deftypevr

@deftypevr {Global variable} string input_dir
This is the base directory for all the input that will be read by Angora. It is interpreted as being relative to @code{angora_basepath}, unless it is preceded by a slash @samp{/}. Unless the path to an input file is absolute (i.e., preceded by a slash @samp{/}), it is interpreted as being relative to @code{input_dir}.

Example:

@example
angora_basepath = "angora_stuff";
input_dir = "input_data";
@end example

With these variable assignments, the input base directory becomes @file{./angora_stuff/input_data/}.
@end deftypevr


@node Logging
@section Logging

@cindex Logging
@cindex Log, keeping

You can keep a log of the simulations run by Angora in a log file, which contains several lines of information for each simulation. First, an estimate of the finishing time and duration of the simulation is written into the log entry. The actual finishing time and duration is added to the log entry upon completion of the simulation. 

Here is an example entry for a simulation in the log file:

@example
johndoe started Angora on 02/22/12 11:54:36AM
    Estimated to finish on 02/22/12 11:54:42AM
    Estimated duration : 6 seconds.
    Simulation finished on 02/22/12 11:54:42AM
    Elapsed time : 6 seconds.
@end example

@deftypevr {Global variable} boolean enable_logging  (default: @code{"true"})
If set to @samp{true}, Angora will keep a record of the simulations that it runs in a log file. The name of this log file is specified by the @code{log_file_name} variable, and the directory in which this file resides is specified by the @code{log_output_dir} variable.
@end deftypevr

@deftypevr {Global variable} string log_file_name  (default: @code{"angora.log"})
This is the name of the Angora log file. It resides in the  directory specified by the @code{log_output_dir} variable.
@end deftypevr

@deftypevr {Global variable} string log_output_dir  (default: @code{"log"})
This is the directory in which the Angora log file is kept. Unless it is preceded by a slash @samp{/}, it is taken as relative to the base output directory @code{output_dir} (@pxref{Paths}).
@end deftypevr

@node Multiple Simulation Runs
@section Multiple Simulation Runs

@cindex Multiple simulations
@cindex Multiple runs

A number of consecutive Angora simulations can be set up in a single configuration file.

@deftypevr {Global variable} integer number_of_runs  (default: @code{1})
The number of simulation runs is specified by the @code{number_of_runs} variable. The simulation runs (or @emph{runs} for short) are indexed from @code{0} to @code{number_of_runs-1}. You can refer to these indices later in the configuration file for enabling or disabling certain configuration variables for certain runs.
@end deftypevr

@deftypevr {Global variable} {integer-array} disabled_runs (default: none)
This array of integers (see @ref{Arrays}) lists the run indices for simulations that will be skipped.

Example:

@example
disabled_runs = [1,2,3,4,5];
@end example

If @code{number_of_runs} was @code{7}, the above variable will cause only the simulations with indices @code{0} and @code{6} to be run.

@end deftypevr

@deftypevr {Global variable} {integer-array} disabled_run_range (default: none)
If you would like to disable simulations that correspond to a @emph{range} of run indices, you can use this variable. This has to be an array of integers with only two elements (@pxref{Arrays}). Simulations with run indices between (and including) these two integers will be skipped.

The following variable assignment has the same effect as the one in the previous example:

@example
disabled_run_range = [1,5];
@end example
@end deftypevr

Certain variables can be @emph{enabled} or @emph{disabled} for any of the simulation runs using the @code{enabled_for_runs} variable. This variable can be used inside any group structure (see @ref{Groups}) to specify the run indices for which that group is enabled. For example,

@example
number_of_runs = 4;
PointSources:
(
    @{
        //point source #1
        enabled_for_runs = [0,1,2];
        position_x = 0;
        position_y = 0;
        position_z = 0;
        source_orientation = "x_directed";
        waveform_tag = "waveform1";
    @},
    @{
        //point source #2
        enabled_for_runs = [3];
        position_x = 0;
        position_y = 0;
        position_z = 0;
        source_orientation = "x_directed";
        waveform_tag = "waveform2";
    @}
);
@end example

In this example, each group represents a collection of variable assignments that characterize an individual point source. With the @code{enabled_for_runs} variables set as shown, simulations @code{0}, @code{1}, and @code{2} will be run with the first point source; whereas simulation @code{3} will be run with the second point source.

@node Miscellaneous
@section Miscellaneous

@menu
* Auto-Saving the Configuration::    Keeping record of the simulation configuration.
@end menu

@node Auto-Saving the Configuration
@subsection Auto-Saving the Configuration

@cindex Configuration, auto-saving

Angora can automatically save a record of every simulation configuration that it processes.

@deftypevr {Global variable} boolean auto_save_cfg  (default: @code{"false"})
If set to @samp{true}, Angora will automatically write every simulation configuration it runs into another configuration file, and save it in the directory specified by @code{cfg_output_dir}. A time/date string is appended to the name of the saved file to differentiate between subsequent executions of the same configuration file.
@end deftypevr

@deftypevr {Global variable} string cfg_output_dir  (default: @code{"cfg"})
This is the directory in which the auto-saved configuration files are placed. Unless it is preceded by a slash @samp{/}, it is taken as relative to the base output directory @code{output_dir} (@pxref{Paths}).
@end deftypevr

@node References
@chapter References

@anchor{Roden00} J. A. Roden and S. D. Gedney, "Convolution PML (CPML): an efficient FDTD implementation of the CFD-PML for arbitrary media," Microw. Opt. Technol. Lett., vol. 27, pp. 334-9, Dec. 2000.

@anchor{Kuzuoglu96} M. Kuzuoglu and R. Mittra, "Frequency dependence of the constitutive parameters of causal perfectly matched absorbers," IEEE Microwave Guided Wave Lett., vol. 6, pp. 447-449, Dec. 1996.

@anchor{Berenger02} J.-P. Berenger,"Numerical reflection from FDTD-PMLs: a comparison of the split PML with the unsplit and CFS PMLs," IEEE Trans. Antennas Propag, vol. 50, pp.258-265, Mar 2002.

@anchor{Rogers09} J. D. Rogers, I. R. Capoglu, V. Backman, "Nonscalar elastic light scattering from continuous media in the Born approximation", Optics Letters, vol. 34, no. 12, pp. 1891-1893, 2009.

@ifnotinfo
@node List of Figures
@unnumbered List of Figures
@listoffloats Figure
@end ifnotinfo

@node Indices
@unnumbered Indices

@menu
* Configuration Variable Index::    Index of Angora configuration variables.
* Concept Index::    Index of Angora concepts.
@end menu

@node Configuration Variable Index
@unnumberedsec Configuration Variable Index

@printindex vr

@node Concept Index
@unnumberedsec Concept Index

@printindex cp

@bye
